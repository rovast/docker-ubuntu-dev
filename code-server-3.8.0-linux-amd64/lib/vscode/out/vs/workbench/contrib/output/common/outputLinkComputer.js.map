{"version":3,"sources":["vs/workbench/contrib/output/common/fake","vs/workbench/contrib/output/common/file:/github/workspace/lib/vscode/src/vs/base/common/async.ts","vs/workbench/contrib/output/common/file:/github/workspace/lib/vscode/src/vs/base/common/extpath.ts","vs/workbench/contrib/output/common/file:/github/workspace/lib/vscode/src/vs/base/common/network.ts","vs/workbench/contrib/output/common/file:/github/workspace/lib/vscode/src/vs/base/common/map.ts","vs/workbench/contrib/output/common/file:/github/workspace/lib/vscode/src/vs/base/common/glob.ts","vs/workbench/contrib/output/common/file:/github/workspace/lib/vscode/src/vs/base/common/resources.ts","vs/workbench/contrib/output/common/file:/github/workspace/lib/vscode/src/vs/workbench/contrib/output/common/outputLinkComputer.ts"],"names":["__m","__M","deps","result","i","len","length","isThenable","obj","then","createCancelablePromise","callback","source","cancellation_1","CancellationTokenSource","thenable","token","promise","Promise","resolve","reject","onCancellationRequested","errors","canceled","value","dispose","err","[object Object]","cancel","this","undefined","onfinally","finally","exports","raceCancellation","defaultValue","race","raceCancellablePromises","async","cancellablePromises","resolvedPromiseIndex","promises","map","index","forEach","cancellablePromise","raceTimeout","timeout","onTimeout","promiseResolve","timer","setTimeout","clearTimeout","asPromise","item","Throttler","activePromise","queuedPromise","queuedPromiseFactory","promiseFactory","onComplete","queue","c","e","Sequencer","current","promiseTask","SequencerByKey","promiseMap","Map","key","newPromise","_a","get","catch","delete","set","Delayer","defaultDelay","completionPromise","doResolve","doReject","task","delay","cancelTimeout","ThrottledDelayer","delayer","throttler","trigger","isTriggered","millis","handle","Barrier","_isOpen","_promise","_completePromise","disposableTimeout","handler","lifecycle_1","toDisposable","ignoreErrors","_","sequence","promiseFactories","results","thenHandler","push","n","first","shouldStop","t","loop","factory","Limiter","maxDegreeOfParalellism","_size","outstandingPromises","runningPromises","_onFinished","event_1","Emitter","onFinished","event","size","consume","iLimitedTask","shift","consumed","fire","Queue","super","ResourceQueue","queues","resource","toString","has","clear","TimeoutTimer","runner","_token","setIfNotSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","bind","isScheduled","doRun","RunOnceWorker","units","unit","schedule","requestIdleCallback","cancelIdleCallback","dummyIdle","Object","freeze","didTimeout","timeRemaining","runWhenIdle","disposed","IdleValue","executor","_didRun","_executor","_value","_error","_handle","retry","retries","lastError","error","TaskSequentializer","taskId","_pending","pending","onCancel","donePending","triggerNext","_next","next","run","promiseReject","IntervalCounter","lastIncrementTime","now","Date","isPathSeparator","code","toSlashes","osPath","replace","path_1","posix","sep","getRoot","path","firstLetter","charCodeAt","pos","start","slice","isWindowsDriveLetter","indexOf","isUNC","platform_1","isWindows","isNaN","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","char0","isValidBasename","name","isWindowsOS","invalidFileChars","test","lastIndex","trim","isEqual","pathA","pathB","ignoreCase","identityEquals","strings_1","equalsIgnoreCase","isEqualOrParent","base","parentCandidate","separator","startsWithIgnoreCase","sepOffset","charAt","sanitizeFilePath","candidate","cwd","endsWith","isAbsolute","join","normalize","rtrim","isRootOrDriveLetter","pathNormalized","indexOfPath","toLowerCase","parseLineAndColumnAware","rawPath","segments","split","line","column","segment","segmentAsNumber","Number","types_1","isNumber","Error","Schemas","inMemory","vscode","internal","walkThrough","walkThroughSnippet","http","https","file","mailto","untitled","data","command","vscodeRemote","vscodeRemoteResource","userData","vscodeCustomEditor","vscodeNotebook","vscodeNotebookCell","vscodeSettings","webviewPanel","vscodeWebview","vscodeWebviewResource","extension","RemoteAuthorities","_hosts","create","_ports","_connectionTokens","_preferredWebSchema","_delegate","schema","delegate","authority","host","port","connectionToken","uri","query","encodeURIComponent","uri_1","URI","from","scheme","platform","isWeb","window","location","pathname","FileAccess","uriOrModule","moduleIdToUrl","toUri","rewrite","isUri","parse","toUrl","getOrSet","mapToString","entries","setToString","StringIterator","_pos","a","PathIterator","_splitOnBackslash","_caseSensitive","_from","_to","justSeps","ch","compareSubstring","compareSubstringIgnoreCase","substring","UriIteratorState","UriIterator","_ignorePathCasing","_states","_stateIdx","_pathIterator","network_1","isLinux","reset","fragment","hasNext","compareIgnoreCase","cmp","compare","TernarySearchTreeNode","left","mid","right","TernarySearchTree","_iter","ignorePathCasing","_root","element","iter","node","val","oldElement","_delete","superStr","stack","isEmpty","dir","parent","pop","_values","Symbol","iterator","_entries","ResourceMap","mapOrKeyFn","toKey","toStringTag","defaultToKey","clb","thisArg","values","keys","tuple","Touch","LinkedMap","_map","_head","_tail","_state","last","touch","previous","addItemLast","addItemFirst","remove","removeItem","callbackfn","state","done","newSize","currentSize","LRUCache","limit","ratio","_limit","_ratio","Math","min","max","checkTrim","trimOld","round","getEmptyExpression","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","pattern","splitChar","inBraces","inBrackets","curVal","char","T1","T2","T3","T3_2","T4","T5","CACHE","map_1","FALSE","NULL","parsePattern","arg1","options","patternKey","trimForExclusions","match","parsedPattern","wrapRelativePattern","substr","basename","exec","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","parsedPatterns","aggregateBasenameMatches","filter","withBasenames","find","allPaths","reduce","all","concat","trivia3","trivia4and5","regExp","RegExp","parseRegExp","regEx","every","s","previousSegmentWasGlobStar","braceVal","bracketVal","braceRegExp","strings","escapeRegExpCharacters","res","toRegExp","arg2","extpath","paths","relative","matchPathEnds","nativePath","nativePathEnd","isRelativePattern","resultPattern","expression","getOwnPropertyNames","when","hasSibling","matched","async_1","m","requiresSiblings","parseExpressionPattern","some","resultExpression","extname","parsedExpression","listToMap","list","rp","basenamePatterns","aggregate","aggregatedPatterns","hasSiblingPromiseFn","siblingsFn","siblings","hasSiblingFn","getBasenameTerms","patternOrExpression","getPathTerms","originalFSPath","uriToFsPath","ExtUri","uri1","uri2","ignoreFragment","getComparisonKey","with","isEqualAuthority","pathFragment","joinPath","dirname","console","normalizedPath","to","relativePath","fromPath","toPath","newURI","a1","a2","fsp","p","fsPath","hasTrailingPathSeparator","isRootSep","extUri","extUriBiasedIgnorePathCase","extUriIgnorePathCase","basenameOrAuthority","normalizePath","resolvePath","isAbsolutePath","removeTrailingPathSeparator","addTrailingPathSeparator","distinctParents","items","resourceAccessor","candidateResource","otherItem","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","lastIndexOf","property","mime","ResourceGlobMatcher","globalExpression","rootExpressions","expressionsByRoot","forUris","glob_1","root","rootExpression","findSubstr","toLocalResource","localScheme","OutputLinkComputer","ctx","createData","computePatterns","workspaceFolders","sort","resourceStrA","resourceStrB","resourceStr","workspaceFolder","createPatterns","getMirrorModels","model","getModel","links","lines","getValue","folderUri","folderPatterns","resourceCreator","toResource","folderRelativePath","resources","detectLinks","workspaceFolderPath","workspaceFolderVariants","workspaceFolderVariant","validPathCharacterPattern","pathPattern","strictPathPattern","lineIndex","offset","resourceString","lineNumber","columnNumber","format","fullMatch","linkRange","startColumn","startLineNumber","endColumn","endLineNumber","link","range_1","Range","areIntersectingOrTouching","range","url","call"],"mappings":"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","file":"outputLinkComputer.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn Promise.race([promise, new Promise<T | undefined>(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n\n/**\n * Returns as soon as one of the promises is resolved and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst result = await Promise.race(promises);\n\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\tif (index !== resolvedPromiseIndex) {\n\t\t\tcancellablePromise.cancel();\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<any>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tif (this.doResolve) {\n\t\t\t\tthis.doResolve(null);\n\t\t\t}\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tif (this.doReject) {\n\t\t\t\tthis.doReject(errors.canceled());\n\t\t\t}\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tget onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tqueueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues.has(key)) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn this.queues.get(key)!;\n\t}\n\n\tdispose(): void {\n\t\tthis.queues.forEach(queue => queue.dispose());\n\t\tthis.queues.clear();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\ttaskId: number;\n\tcancel: () => void;\n\tpromise: Promise<void>;\n}\n\ninterface ISequentialTask {\n\tpromise: Promise<void>;\n\tpromiseResolve: () => void;\n\tpromiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport class TaskSequentializer {\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: ISequentialTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending ? this._pending.promise : undefined;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId: taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number) { }\n\n\tincrement(): number {\n\t\tconst now = Date.now();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { startsWithIgnoreCase, equalsIgnoreCase, rtrim } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { sep, posix, isAbsolute, join, normalize } from 'vs/base/common/path';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(1);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(pos + 1);\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isWindowsDriveLetter(pathNormalized.charCodeAt(0))\n\t\t\t&& pathNormalized.charCodeAt(1) === CharCode.Colon\n\t\t\t&& (path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tsegments.forEach(segment => {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t});\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport * as platform from 'vs/base/common/platform';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const userData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebook = 'vscode-notebook';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for loading resources inside of webviews.\n\t */\n\texport const vscodeWebviewResource = 'vscode-webview-resource';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n}\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined; } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\treturn this._delegate(uri);\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\t// const port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&tkn=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\t// NOTE@coder: Changed this to work against the current path.\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: window.location.host,\n\t\t\tpath: `${window.location.pathname.replace(/\\/+$/, '')}/vscode-remote-resource`,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nclass FileAccessImpl {\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(uri: URI): URI;\n\tasBrowserUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasBrowserUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(uri: URI): URI;\n\tasFileUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasFileUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl!.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { compareSubstringIgnoreCase, compare, compareSubstring, compareIgnoreCase } from 'vs/base/common/strings';\nimport { isLinux } from 'vs/base/common/platform';\nimport { Schemas } from 'vs/base/common/network';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport interface IKeyIterator<K> {\n\treset(key: K): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator<string> {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class PathIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _splitOnBackslash: boolean = true,\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._value = key.replace(/\\\\$|\\/$/, '');\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nconst enum UriIteratorState {\n\tScheme = 1, Authority = 2, Path = 3, Query = 4, Fragment = 5\n}\n\nexport class UriIterator implements IKeyIterator<URI> {\n\n\tprivate _pathIterator!: PathIterator;\n\tprivate _value!: URI;\n\tprivate _states: UriIteratorState[] = [];\n\tprivate _stateIdx: number = 0;\n\n\tconstructor(private readonly _ignorePathCasing: boolean | undefined) { }\n\n\treset(key: URI): this {\n\t\tthis._value = key;\n\t\tthis._states = [];\n\t\tif (this._value.scheme) {\n\t\t\tthis._states.push(UriIteratorState.Scheme);\n\t\t}\n\t\tif (this._value.authority) {\n\t\t\tthis._states.push(UriIteratorState.Authority);\n\t\t}\n\t\tif (this._value.path) {\n\t\t\tthis._pathIterator = new PathIterator(false, this._ignorePathCasing === undefined\n\t\t\t\t? key.scheme === Schemas.file && isLinux\n\t\t\t\t: !this._ignorePathCasing\n\t\t\t);\n\t\t\tthis._pathIterator.reset(key.path);\n\t\t\tif (this._pathIterator.value()) {\n\t\t\t\tthis._states.push(UriIteratorState.Path);\n\t\t\t}\n\t\t}\n\t\tif (this._value.query) {\n\t\t\tthis._states.push(UriIteratorState.Query);\n\t\t}\n\t\tif (this._value.fragment) {\n\t\t\tthis._states.push(UriIteratorState.Fragment);\n\t\t}\n\t\tthis._stateIdx = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {\n\t\t\tthis._pathIterator.next();\n\t\t} else {\n\t\t\tthis._stateIdx += 1;\n\t\t}\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext())\n\t\t\t|| this._stateIdx < this._states.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn compareIgnoreCase(a, this._value.scheme);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn compareIgnoreCase(a, this._value.authority);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.cmp(a);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn compare(a, this._value.query);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn compare(a, this._value.fragment);\n\t\t}\n\t\tthrow new Error();\n\t}\n\n\tvalue(): string {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn this._value.scheme;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn this._value.authority;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.value();\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn this._value.query;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn this._value.fragment;\n\t\t}\n\t\tthrow new Error();\n\t}\n}\n\nclass TernarySearchTreeNode<K, V> {\n\tsegment!: string;\n\tvalue: V | undefined;\n\tkey!: K;\n\tleft: TernarySearchTreeNode<K, V> | undefined;\n\tmid: TernarySearchTreeNode<K, V> | undefined;\n\tright: TernarySearchTreeNode<K, V> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n}\n\nexport class TernarySearchTree<K, V> {\n\n\tstatic forUris<E>(ignorePathCasing?: boolean): TernarySearchTree<URI, E> {\n\t\treturn new TernarySearchTree<URI, E>(new UriIterator(ignorePathCasing));\n\t}\n\n\tstatic forPaths<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new PathIterator());\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new StringIterator());\n\t}\n\n\tprivate _iter: IKeyIterator<K>;\n\tprivate _root: TernarySearchTreeNode<K, V> | undefined;\n\n\tconstructor(segments: IKeyIterator<K>) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\tset(key: K, element: V): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<K, V>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<K, V>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\t\treturn oldElement;\n\t}\n\n\tget(key: K): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node ? node.value : undefined;\n\t}\n\n\tdelete(key: K): void {\n\t\treturn this._delete(key, false);\n\t}\n\n\tdeleteSuperstr(key: K): void {\n\t\treturn this._delete(key, true);\n\t}\n\n\tprivate _delete(key: K, superStr: boolean): void {\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [-1 | 0 | 1, TernarySearchTreeNode<K, V>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find and unset node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([1, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([-1, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([0, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// remove element\n\t\t\t\tnode.value = undefined;\n\n\t\t\t\t// clean up empty nodes\n\t\t\t\twhile (stack.length > 0 && (node.isEmpty() || superStr)) {\n\t\t\t\t\tlet [dir, parent] = stack.pop()!;\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase 1: parent.left = undefined; break;\n\t\t\t\t\t\tcase 0: parent.mid = undefined; break;\n\t\t\t\t\t\tcase -1: parent.right = undefined; break;\n\t\t\t\t\t}\n\t\t\t\t\tnode = parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindSubstr(key: K): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: V | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: K): Iterator<V> | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._values(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tforEach(callback: (value: V, index: K) => any): void {\n\t\tfor (const [key, value] of this) {\n\t\t\tcallback(value, key);\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\tyield* this._entries(this._root);\n\t}\n\n\tprivate *_values(node: TernarySearchTreeNode<K, V>): IterableIterator<V> {\n\t\tfor (const [, value] of this._entries(node)) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\tprivate *_entries(node: TernarySearchTreeNode<K, V> | undefined): IterableIterator<[K, V]> {\n\t\tif (node) {\n\t\t\t// left\n\t\t\tyield* this._entries(node.left);\n\n\t\t\t// node\n\t\t\tif (node.value) {\n\t\t\t\t// callback(node.value, this._iter.join(parts));\n\t\t\t\tyield [node.key, node.value];\n\t\t\t}\n\t\t\t// mid\n\t\t\tyield* this._entries(node.mid);\n\n\t\t\t// right\n\t\t\tyield* this._entries(node.right);\n\t\t}\n\t}\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, T>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\tconstructor(mapOrKeyFn?: ResourceMap<T> | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (mapOrKeyFn instanceof ResourceMap) {\n\t\t\tthis.map = new Map(mapOrKeyFn.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), value);\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource));\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: any): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (let [index, value] of this.map) {\n\t\t\tclb(value, URI.parse(index), <any>this);\n\t\t}\n\t}\n\n\tvalues(): IterableIterator<T> {\n\t\treturn this.map.values();\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (let key of this.map.keys()) {\n\t\t\tyield URI.parse(key);\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (let tuple of this.map.entries()) {\n\t\t\tyield [URI.parse(tuple[0]), tuple[1]];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (let item of this.map) {\n\t\t\tyield [URI.parse(item[0]), item[1]];\n\t\t}\n\t}\n}\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\tget(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\tset(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { LRUCache } from 'vs/base/common/map';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isThenable } from 'vs/base/common/async';\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport interface IRelativePattern {\n\tbase: string;\n\tpattern: string;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tfor (const char of segment) {\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t// range operator\n\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\tres = char;\n\t\t\t\t\t}\n\n\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\tres = '^';\n\t\t\t\t\t}\n\n\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n\t\t\t// a folder called \"something\" to match as well.\n\t\t\t// However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n\t\t\t// is to match 0-N segments.\n\t\t\tif (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t   \t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t   \t\t\t// **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; \t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t   \t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t   \t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The ParsedExpression returns a Promise iff hasSibling returns a Promise.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during tree traversal to skip entire subtrees. Cannot be used outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle IRelativePattern\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivias\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n\t\tconst base = pattern.substr(4); // '**/*'.length === 4\n\t\tparsedPattern = function (path, basename) {\n\t\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t\t};\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\treturn function (path, basename) {\n\t\tif (!extpath.isEqualOrParent(path, arg2.base)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsedPattern(paths.relative(arg2.base, path), basename);\n\t};\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, originalPattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\tconst parsedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (basename) {\n\t\t\treturn basename === base ? originalPattern : null;\n\t\t}\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n\t};\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [originalPattern];\n\tparsedPattern.allBasenames = basenames;\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tif (n === 1) {\n\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t}\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif ((<ParsedStringPattern>parsedPatterns[i])(path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst withBasenames = parsedPatterns.find(pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n\tconst nativePathEnd = paths.sep + nativePath;\n\tconst parsedPattern: ParsedStringPattern = matchPathEnds ? function (path, basename) {\n\t\treturn typeof path === 'string' && (path === nativePath || path.endsWith(nativePathEnd)) ? pattern : null;\n\t} : function (path, basename) {\n\t\treturn typeof path === 'string' && path === nativePath ? pattern : null;\n\t};\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(<IExpression>arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[]; } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern;\n\n\treturn rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (n === 1) {\n\t\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\t// Pattern matches path\n\t\t\t\tconst result = (<ParsedStringPattern>parsedPatterns[i])(path, basename);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = paths.basename(path);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = basename.substr(0, basename.length - paths.extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = parsedPattern(path, basename, name, hasSibling);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = (<SiblingClause>value).when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(m => m ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\t\t\tresult.requiresSiblings = true;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is Anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, <string[]>[]);\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, <string[]>[]);\n\t}\n\tconst aggregate: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbasename = path.substr(i);\n\t\t}\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\treturn aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\nimport { equalsIgnoreCase, compare as strCompare } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isWindows, isLinux } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { ParsedExpression, IExpression, parse } from 'vs/base/common/glob';\nimport { TernarySearchTree } from 'vs/base/common/map';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\"\n\t * @param parentCandidate A uri which is \"shorter\" then `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see ResourceMap\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/', toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tif (path.indexOf('/') === -1) { // no slashes? it's likely a Windows path\n\t\t\tpath = extpath.toSlashes(path);\n\t\t\tif (/^[a-zA-Z]:(\\/|$)/.test(path)) { // starts with a drive letter\n\t\t\t\tpath = '/' + path;\n\t\t\t}\n\t\t}\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string, a2: string) {\n\t\treturn a1 === a2 || equalsIgnoreCase(a1, a2);\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport class ResourceGlobMatcher {\n\n\tprivate readonly globalExpression: ParsedExpression;\n\tprivate readonly expressionsByRoot: TernarySearchTree<URI, { root: URI, expression: ParsedExpression }> = TernarySearchTree.forUris<{ root: URI, expression: ParsedExpression }>();\n\n\tconstructor(\n\t\tglobalExpression: IExpression,\n\t\trootExpressions: { root: URI, expression: IExpression }[]\n\t) {\n\t\tthis.globalExpression = parse(globalExpression);\n\t\tfor (const expression of rootExpressions) {\n\t\t\tthis.expressionsByRoot.set(expression.root, { root: expression.root, expression: parse(expression.expression) });\n\t\t}\n\t}\n\n\tmatches(resource: URI): boolean {\n\t\tconst rootExpression = this.expressionsByRoot.findSubstr(resource);\n\t\tif (rootExpression) {\n\t\t\tconst path = relativePath(rootExpression.root, resource);\n\t\t\tif (path && !!rootExpression.expression(path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn !!this.globalExpression(resource.path);\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMirrorModel, IWorkerContext } from 'vs/editor/common/services/editorSimpleWorker';\nimport { ILink } from 'vs/editor/common/modes';\nimport { URI } from 'vs/base/common/uri';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as resources from 'vs/base/common/resources';\nimport * as strings from 'vs/base/common/strings';\nimport { Range } from 'vs/editor/common/core/range';\nimport { isWindows } from 'vs/base/common/platform';\nimport { Schemas } from 'vs/base/common/network';\n\nexport interface ICreateData {\n\tworkspaceFolders: string[];\n}\n\nexport interface IResourceCreator {\n\ttoResource: (folderRelativePath: string) => URI | null;\n}\n\nexport class OutputLinkComputer {\n\tprivate patterns = new Map<URI /* folder uri */, RegExp[]>();\n\n\tconstructor(private ctx: IWorkerContext, createData: ICreateData) {\n\t\tthis.computePatterns(createData);\n\t}\n\n\tprivate computePatterns(createData: ICreateData): void {\n\n\t\t// Produce patterns for each workspace root we are configured with\n\t\t// This means that we will be able to detect links for paths that\n\t\t// contain any of the workspace roots as segments.\n\t\tconst workspaceFolders = createData.workspaceFolders\n\t\t\t.sort((resourceStrA, resourceStrB) => resourceStrB.length - resourceStrA.length) // longest paths first (for https://github.com/microsoft/vscode/issues/88121)\n\t\t\t.map(resourceStr => URI.parse(resourceStr));\n\n\t\tfor (const workspaceFolder of workspaceFolders) {\n\t\t\tconst patterns = OutputLinkComputer.createPatterns(workspaceFolder);\n\t\t\tthis.patterns.set(workspaceFolder, patterns);\n\t\t}\n\t}\n\n\tprivate getModel(uri: string): IMirrorModel | undefined {\n\t\tconst models = this.ctx.getMirrorModels();\n\n\t\treturn models.find(model => model.uri.toString() === uri);\n\t}\n\n\tcomputeLinks(uri: string): ILink[] {\n\t\tconst model = this.getModel(uri);\n\t\tif (!model) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst links: ILink[] = [];\n\t\tconst lines = model.getValue().split(/\\r\\n|\\r|\\n/);\n\n\t\t// For each workspace root patterns\n\t\tfor (const [folderUri, folderPatterns] of this.patterns) {\n\t\t\tconst resourceCreator: IResourceCreator = {\n\t\t\t\ttoResource: (folderRelativePath: string): URI | null => {\n\t\t\t\t\tif (typeof folderRelativePath === 'string') {\n\t\t\t\t\t\treturn resources.joinPath(folderUri, folderRelativePath);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\t\tlinks.push(...OutputLinkComputer.detectLinks(lines[i], i + 1, folderPatterns, resourceCreator));\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tstatic createPatterns(workspaceFolder: URI): RegExp[] {\n\t\tconst patterns: RegExp[] = [];\n\n\t\tconst workspaceFolderPath = workspaceFolder.scheme === Schemas.file ? workspaceFolder.fsPath : workspaceFolder.path;\n\t\tconst workspaceFolderVariants = [workspaceFolderPath];\n\t\tif (isWindows && workspaceFolder.scheme === Schemas.file) {\n\t\t\tworkspaceFolderVariants.push(extpath.toSlashes(workspaceFolderPath));\n\t\t}\n\n\t\tfor (const workspaceFolderVariant of workspaceFolderVariants) {\n\t\t\tconst validPathCharacterPattern = '[^\\\\s\\\\(\\\\):<>\"]';\n\t\t\tconst validPathCharacterOrSpacePattern = `(?:${validPathCharacterPattern}| ${validPathCharacterPattern})`;\n\t\t\tconst pathPattern = `${validPathCharacterOrSpacePattern}+\\\\.${validPathCharacterPattern}+`;\n\t\t\tconst strictPathPattern = `${validPathCharacterPattern}+`;\n\n\t\t\t// Example: /workspaces/express/server.js on line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}) on line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/express/server.js:line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}):line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/mankala/Features.ts(45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts(45,18): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45,18): error\n\t\t\t// Example: /workspaces/mankala/Features Special.ts (45,18): error\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern})(\\\\s?\\\\((\\\\d+)(,(\\\\d+))?)\\\\)`, 'gi'));\n\n\t\t\t// Example: at /workspaces/mankala/Game.ts\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336:9\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${strictPathPattern})(:(\\\\d+))?(:(\\\\d+))?`, 'gi'));\n\t\t}\n\n\t\treturn patterns;\n\t}\n\n\t/**\n\t * Detect links. Made static to allow for tests.\n\t */\n\tstatic detectLinks(line: string, lineIndex: number, patterns: RegExp[], resourceCreator: IResourceCreator): ILink[] {\n\t\tconst links: ILink[] = [];\n\n\t\tpatterns.forEach(pattern => {\n\t\t\tpattern.lastIndex = 0; // the holy grail of software development\n\n\t\t\tlet match: RegExpExecArray | null;\n\t\t\tlet offset = 0;\n\t\t\twhile ((match = pattern.exec(line)) !== null) {\n\n\t\t\t\t// Convert the relative path information to a resource that we can use in links\n\t\t\t\tconst folderRelativePath = strings.rtrim(match[1], '.').replace(/\\\\/g, '/'); // remove trailing \".\" that likely indicate end of sentence\n\t\t\t\tlet resourceString: string | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tconst resource = resourceCreator.toResource(folderRelativePath);\n\t\t\t\t\tif (resource) {\n\t\t\t\t\t\tresourceString = resource.toString();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcontinue; // we might find an invalid URI and then we dont want to loose all other links\n\t\t\t\t}\n\n\t\t\t\t// Append line/col information to URI if matching\n\t\t\t\tif (match[3]) {\n\t\t\t\t\tconst lineNumber = match[3];\n\n\t\t\t\t\tif (match[5]) {\n\t\t\t\t\t\tconst columnNumber = match[5];\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1},{2}', resourceString, lineNumber, columnNumber);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1}', resourceString, lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst fullMatch = strings.rtrim(match[0], '.'); // remove trailing \".\" that likely indicate end of sentence\n\n\t\t\t\tconst index = line.indexOf(fullMatch, offset);\n\t\t\t\toffset = index + fullMatch.length;\n\n\t\t\t\tconst linkRange = {\n\t\t\t\t\tstartColumn: index + 1,\n\t\t\t\t\tstartLineNumber: lineIndex,\n\t\t\t\t\tendColumn: index + 1 + fullMatch.length,\n\t\t\t\t\tendLineNumber: lineIndex\n\t\t\t\t};\n\n\t\t\t\tif (links.some(link => Range.areIntersectingOrTouching(link.range, linkRange))) {\n\t\t\t\t\treturn; // Do not detect duplicate links\n\t\t\t\t}\n\n\t\t\t\tlinks.push({\n\t\t\t\t\trange: linkRange,\n\t\t\t\t\turl: resourceString\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn links;\n\t}\n}\n\nexport function create(ctx: IWorkerContext, createData: ICreateData): OutputLinkComputer {\n\treturn new OutputLinkComputer(ctx, createData);\n}\n"]}